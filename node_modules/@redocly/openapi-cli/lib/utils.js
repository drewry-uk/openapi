"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.printExecutionTime = exports.getExecutionTime = exports.promptUser = exports.match = exports.readFileFromUrl = exports.notUndefined = exports.writeYaml = exports.readYaml = exports.loadYaml = exports.saveBundle = exports.CircularJSONNotSupportedError = exports.dumpBundle = exports.popStack = exports.pushStack = void 0;
const yaml = require("js-yaml");
const fs = require("fs");
const path = require("path");
const minimatch = require("minimatch");
const node_fetch_1 = require("node-fetch");
const readline = require("readline");
const perf_hooks_1 = require("perf_hooks");
const colors = require("colorette");
function pushStack(head, value) {
    return { prev: head, value };
}
exports.pushStack = pushStack;
function popStack(head) {
    var _a;
    return (_a = head === null || head === void 0 ? void 0 : head.prev) !== null && _a !== void 0 ? _a : null;
}
exports.popStack = popStack;
function dumpBundle(obj, format, dereference) {
    if (format === 'json') {
        try {
            return JSON.stringify(obj, null, 2);
        }
        catch (e) {
            if (e.message.indexOf('circular') > -1) {
                throw new CircularJSONNotSupportedError(e);
            }
            throw e;
        }
    }
    else {
        return yaml.safeDump(obj, {
            noRefs: !dereference,
        });
    }
}
exports.dumpBundle = dumpBundle;
class CircularJSONNotSupportedError extends Error {
    constructor(originalError) {
        super(originalError.message);
        this.originalError = originalError;
        // Set the prototype explicitly.
        Object.setPrototypeOf(this, CircularJSONNotSupportedError.prototype);
    }
}
exports.CircularJSONNotSupportedError = CircularJSONNotSupportedError;
function saveBundle(filename, output) {
    fs.mkdirSync(path.dirname(filename), { recursive: true });
    fs.writeFileSync(filename, output);
}
exports.saveBundle = saveBundle;
function loadYaml(filename) {
    return __awaiter(this, void 0, void 0, function* () {
        const contents = yield fs.promises.readFile(filename, 'utf-8');
        return yaml.safeLoad(contents);
    });
}
exports.loadYaml = loadYaml;
function readYaml(filename) {
    return yaml.safeLoad(fs.readFileSync(filename, 'utf-8'), { filename });
}
exports.readYaml = readYaml;
function writeYaml(data, filename) {
    return fs.writeFileSync(filename, yaml.safeDump(data));
}
exports.writeYaml = writeYaml;
function notUndefined(x) {
    return x !== undefined;
}
exports.notUndefined = notUndefined;
function readFileFromUrl(url, config) {
    return __awaiter(this, void 0, void 0, function* () {
        const headers = {};
        for (const header of config.headers) {
            if (match(url, header.matches)) {
                headers[header.name] =
                    header.envVariable !== undefined ? process.env[header.envVariable] || '' : header.value;
            }
        }
        const req = yield (config.customFetch || node_fetch_1.default)(url, {
            headers: headers,
        });
        if (!req.ok) {
            throw new Error(`Failed to load ${url}: ${req.status} ${req.statusText}`);
        }
        return { body: yield req.text(), mimeType: req.headers.get('content-type') };
    });
}
exports.readFileFromUrl = readFileFromUrl;
function match(url, pattern) {
    if (!pattern.match(/^https?:\/\//)) {
        // if pattern doesn't specify protocol directly, do not match against it
        url = url.replace(/^https?:\/\//, '');
    }
    return minimatch(url, pattern);
}
exports.match = match;
function promptUser(query) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
            const rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout,
            });
            rl.question(`${query}:\n\n  `, (answer) => {
                rl.close();
                resolve(answer);
            });
        });
    });
}
exports.promptUser = promptUser;
function getExecutionTime(startedAt) {
    return process.env.NODE_ENV === 'test'
        ? '<test>ms'
        : `${Math.ceil(perf_hooks_1.performance.now() - startedAt)}ms`;
}
exports.getExecutionTime = getExecutionTime;
function printExecutionTime(commandName, startedAt, entrypoint) {
    const elapsed = getExecutionTime(startedAt);
    process.stderr.write(colors.gray(`\n${entrypoint}: ${commandName} processed in ${elapsed}\n\n`));
}
exports.printExecutionTime = printExecutionTime;
