"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleStats = void 0;
const perf_hooks_1 = require("perf_hooks");
const colors = require("colorette");
const __1 = require("..");
const types_1 = require("../types");
const oas3_1 = require("../types/oas3");
const oas2_1 = require("../types/oas2");
const resolve_1 = require("../resolve");
const validate_1 = require("../validate");
const visitors_1 = require("../visitors");
const walk_1 = require("../walk");
const cli_1 = require("../cli");
const utils_1 = require("../utils");
const stats_1 = require("../rules/other/stats");
const statsAccumulator = {
    refs: { metric: 'üöó References', total: 0, color: 'red', items: new Set() },
    externalDocs: { metric: 'üì¶ External Documents', total: 0, color: 'magenta' },
    schemas: { metric: 'üìà Schemas', total: 0, color: 'white' },
    parameters: { metric: 'üëâ Parameters', total: 0, color: 'yellow', items: new Set() },
    links: { metric: 'üîó Links', total: 0, color: 'cyan', items: new Set() },
    pathItems: { metric: '‚û°Ô∏è Path Items', total: 0, color: 'green' },
    operations: { metric: 'üë∑ Operations', total: 0, color: 'yellow' },
    tags: { metric: 'üîñ Tags', total: 0, color: 'white', items: new Set() },
};
function printStatsStylish(statsAccumulator) {
    for (const node in statsAccumulator) {
        const { metric, total, color } = statsAccumulator[node];
        process.stderr.write(colors[color](`${metric}: ${total} \n`));
    }
}
function printStatsJson(statsAccumulator) {
    const json = {};
    for (const key of Object.keys(statsAccumulator)) {
        json[key] = {
            metric: statsAccumulator[key].metric,
            total: statsAccumulator[key].total,
        };
    }
    process.stdout.write(JSON.stringify(json, null, 2));
}
function printStats(statsAccumulator, entrypoint, format) {
    process.stderr.write(`Document: ${colors.magenta(entrypoint)} stats:\n\n`);
    switch (format) {
        case 'stylish':
            printStatsStylish(statsAccumulator);
            break;
        case 'json':
            printStatsJson(statsAccumulator);
            break;
    }
}
function handleStats(argv) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = yield __1.loadConfig(argv.config);
        const entrypoints = yield cli_1.getFallbackEntryPointsOrExit(argv.entrypoint ? [argv.entrypoint] : [], config);
        const entrypoint = entrypoints[0];
        const externalRefResolver = new resolve_1.BaseResolver(config.resolve);
        const document = (yield externalRefResolver.resolveDocument(null, entrypoint));
        const lintConfig = config.lint;
        const oasVersion = validate_1.detectOpenAPI(document.parsed);
        const oasMajorVersion = validate_1.openAPIMajor(oasVersion);
        const types = types_1.normalizeTypes(lintConfig.extendTypes(oasMajorVersion === validate_1.OasMajorVersion.Version3 ? oas3_1.Oas3Types : oas2_1.Oas2Types, oasVersion));
        const startedAt = perf_hooks_1.performance.now();
        const ctx = {
            problems: [],
            oasVersion: oasVersion,
        };
        const resolvedRefMap = yield resolve_1.resolveDocument({
            rootDocument: document,
            rootType: types.DefinitionRoot,
            externalRefResolver,
        });
        const statsVisitor = visitors_1.normalizeVisitors([{
                severity: 'warn',
                ruleId: 'stats',
                visitor: stats_1.Stats(statsAccumulator)
            }], types);
        walk_1.walkDocument({
            document,
            rootType: types.DefinitionRoot,
            normalizedVisitors: statsVisitor,
            resolvedRefMap,
            ctx,
        });
        printStats(statsAccumulator, entrypoint, argv.format);
        utils_1.printExecutionTime('stats', startedAt, entrypoint);
    });
}
exports.handleStats = handleStats;
