#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFallbackEntryPointsOrExit = exports.getTotals = void 0;
const yargs = require("yargs");
const path_1 = require("path");
const colorette_1 = require("colorette");
const perf_hooks_1 = require("perf_hooks");
const glob = require("glob-promise");
const validate_1 = require("./validate");
const bundle_1 = require("./bundle");
const utils_1 = require("./utils");
const format_1 = require("./format/format");
const resolve_1 = require("./resolve");
const config_1 = require("./config/config");
const preview_docs_1 = require("./cli/preview-docs");
const stats_1 = require("./cli/stats");
const split_1 = require("./cli/split");
const redocly_1 = require("./redocly");
const version = require('../package.json').version;
const outputExtensions = ['json', 'yaml', 'yml'];
const ERROR_MESSAGE = {
    MISSING_ARGUMENT: 'error: missing required argument `entrypoints`.\n'
};
yargs
    .version('version', 'Show version number.', version)
    .help('help', 'Show help.')
    .command('stats [entrypoint]', 'Gathering statistics for a document', (yargs) => yargs
    .positional('entrypoint', { type: 'string' })
    .option({
    config: { description: 'Specify path to the config file.', type: 'string' },
    format: {
        description: 'Use a specific output format.',
        choices: ['stylish', 'json'],
        default: 'stylish',
    }
}), (argv) => __awaiter(void 0, void 0, void 0, function* () { stats_1.handleStats(argv); }))
    .command('split [entrypoint]', 'Split definition into a multi-file structure', (yargs) => yargs
    .positional('entrypoint', { type: 'string' })
    .option({ outDir: {
        description: 'Output directory where files will be saved',
        required: true,
        type: 'string'
    } }), (argv) => { split_1.handleSplit(argv); })
    .command('lint [entrypoints...]', 'Lint definition.', (yargs) => yargs
    .positional('entrypoints', {
    array: true,
    type: 'string',
    demandOption: true,
})
    .option('format', {
    description: 'Use a specific output format.',
    choices: ['stylish', 'codeframe', 'json'],
    default: 'codeframe',
})
    .option('max-problems', {
    requiresArg: true,
    description: 'Reduce output to max N problems.',
    type: 'number',
    default: 100,
})
    .option('generate-ignore-file', {
    description: 'Generate ignore file.',
    type: 'boolean',
})
    .option('skip-rule', {
    description: 'Ignore certain rules.',
    array: true,
    type: 'string',
})
    .option('skip-preprocessor', {
    description: 'Ignore certain preprocessors.',
    array: true,
    type: 'string',
})
    .option('config', {
    description: 'Specify path to the config file.',
    requiresArg: true,
    type: 'string',
})
    .option('extends', {
    description: 'Override extends configurations (defaults or config file settings).',
    requiresArg: true,
    array: true,
    type: 'string',
}), (argv) => __awaiter(void 0, void 0, void 0, function* () {
    const config = yield config_1.loadConfig(argv.config, argv.extends);
    config.lint.skipRules(argv['skip-rule']);
    config.lint.skipPreprocessors(argv['skip-preprocessor']);
    const entrypoints = yield getFallbackEntryPointsOrExit(argv.entrypoints, config);
    if (argv['generate-ignore-file']) {
        config.lint.ignore = {}; // clear ignore
    }
    const totals = { errors: 0, warnings: 0, ignored: 0 };
    let totalIgnored = 0;
    if (config.lint.recommendedFallback) {
        process.stderr.write(`No configurations were defined in extends -- using built in ${colorette_1.blue('recommended')} configuration by default.\n\n`);
    }
    // TODO: use shared externalRef resolver, blocked by preprocessors now as they can mutate documents
    for (const entryPoint of entrypoints) {
        try {
            const startedAt = perf_hooks_1.performance.now();
            process.stderr.write(colorette_1.gray(`validating ${entryPoint}...\n`));
            const results = yield validate_1.validate({
                ref: entryPoint,
                config,
            });
            const fileTotals = getTotals(results);
            totals.errors += fileTotals.errors;
            totals.warnings += fileTotals.warnings;
            totals.ignored += fileTotals.ignored;
            if (argv['generate-ignore-file']) {
                for (let m of results) {
                    config.lint.addIgnore(m);
                    totalIgnored++;
                }
            }
            else {
                format_1.formatProblems(results, {
                    format: argv.format,
                    maxProblems: argv['max-problems'],
                    totals: fileTotals,
                    version
                });
            }
            const elapsed = utils_1.getExecutionTime(startedAt);
            process.stderr.write(colorette_1.gray(`${entryPoint}: validated in ${elapsed}\n\n`));
        }
        catch (e) {
            totals.errors++;
            handleError(e, entryPoint);
        }
    }
    if (argv['generate-ignore-file']) {
        config.lint.saveIgnore();
        process.stderr.write(`Generated ignore file with ${totalIgnored} ${pluralize('problem', totalIgnored)}.\n\n`);
    }
    else {
        printLintTotals(totals, entrypoints.length);
    }
    printUnusedWarnings(config.lint);
    process.exit(totals.errors === 0 || argv['generate-ignore-file'] ? 0 : 1);
}))
    .command('bundle [entrypoints...]', 'Bundle definition.', (yargs) => yargs
    .positional('entrypoints', {
    array: true,
    type: 'string',
    demandOption: true,
})
    .options({
    output: { type: 'string', alias: 'o' },
})
    .option('format', {
    description: 'Use a specific output format.',
    choices: ['stylish', 'codeframe', 'json'],
    default: 'codeframe',
})
    .option('max-problems', {
    requiresArg: true,
    description: 'Reduce output to max N problems.',
    type: 'number',
    default: 100,
})
    .option('ext', {
    description: 'Bundle file extension.',
    requiresArg: true,
    choices: outputExtensions,
})
    .option('skip-rule', {
    description: 'Ignore certain rules.',
    array: true,
    type: 'string',
})
    .option('skip-preprocessor', {
    description: 'Ignore certain preprocessors.',
    array: true,
    type: 'string',
})
    .option('skip-decorator', {
    description: 'Ignore certain decorators.',
    array: true,
    type: 'string',
})
    .option('dereferenced', {
    alias: 'd',
    type: 'boolean',
    description: 'Produce fully dereferenced bundle.',
})
    .option('force', {
    alias: 'f',
    type: 'boolean',
    description: 'Produce bundle output even when errors occur.',
})
    .option('config', {
    description: 'Specify path to the config file.',
    type: 'string',
}), (argv) => __awaiter(void 0, void 0, void 0, function* () {
    const config = yield config_1.loadConfig(argv.config);
    config.lint.skipRules(argv['skip-rule']);
    config.lint.skipPreprocessors(argv['skip-preprocessor']);
    config.lint.skipDecorators(argv['skip-decorator']);
    const entrypoints = yield getFallbackEntryPointsOrExit(argv.entrypoints, config);
    const totals = { errors: 0, warnings: 0, ignored: 0 };
    for (const entrypoint of entrypoints) {
        try {
            const startedAt = perf_hooks_1.performance.now();
            process.stderr.write(colorette_1.gray(`bundling ${entrypoint}...\n`));
            const { bundle: result, problems } = yield bundle_1.bundle({
                config,
                ref: entrypoint,
                dereference: argv.dereferenced,
            });
            const fileTotals = getTotals(problems);
            const { outputFile, ext } = getOutputFileName(entrypoint, entrypoints.length, argv.output, argv.ext);
            if (fileTotals.errors === 0 || argv.force) {
                if (!argv.output) {
                    const output = utils_1.dumpBundle(result, argv.ext || 'yaml', argv.dereferenced);
                    process.stdout.write(output);
                }
                else {
                    const output = utils_1.dumpBundle(result, ext, argv.dereferenced);
                    utils_1.saveBundle(outputFile, output);
                }
            }
            totals.errors += fileTotals.errors;
            totals.warnings += fileTotals.warnings;
            totals.ignored += fileTotals.ignored;
            format_1.formatProblems(problems, {
                format: argv.format,
                maxProblems: argv['max-problems'],
                totals: fileTotals,
                version,
            });
            const elapsed = utils_1.getExecutionTime(startedAt);
            if (fileTotals.errors > 0) {
                if (argv.force) {
                    process.stderr.write(`❓ Created a bundle for ${colorette_1.blue(entrypoint)} at ${colorette_1.blue(outputFile)} with errors ${colorette_1.green(elapsed)}.\n${colorette_1.yellow('Errors ignored because of --force')}.\n`);
                }
                else {
                    process.stderr.write(`❌ Errors encountered while bundling ${colorette_1.blue(entrypoint)}: bundle not created (use --force to ignore errors).\n`);
                }
            }
            else {
                process.stderr.write(`📦 Created a bundle for ${colorette_1.blue(entrypoint)} at ${colorette_1.blue(outputFile)} ${colorette_1.green(elapsed)}.\n`);
            }
        }
        catch (e) {
            handleError(e, entrypoint);
        }
    }
    printUnusedWarnings(config.lint);
    process.exit(totals.errors === 0 || argv.force ? 0 : 1);
}))
    .command('login', 'Login to the Redoc.ly API registry with an access token.', () => __awaiter(void 0, void 0, void 0, function* () {
    const clientToken = yield utils_1.promptUser(colorette_1.green(`\n  🔑 Copy your access token from ${colorette_1.blue(`https://app.${process.env.REDOCLY_DOMAIN || 'redoc.ly'}/profile`)} and paste it below`));
    const client = new redocly_1.RedoclyClient();
    client.login(clientToken);
}))
    .command('logout', 'Clear your stored credentials for the Redoc.ly API registry.', () => __awaiter(void 0, void 0, void 0, function* () {
    const client = new redocly_1.RedoclyClient();
    client.logout();
}))
    .command('preview-docs [entrypoint]', 'Preview API reference docs for the specified definition.', (yargs) => yargs
    .positional('entrypoint', {
    type: 'string',
})
    .option('port', {
    alias: 'p',
    type: 'number',
    default: 8080,
    description: 'Preview port.',
})
    .option('skip-preprocessor', {
    description: 'Ignore certain preprocessors.',
    array: true,
    type: 'string',
})
    .option('skip-decorator', {
    description: 'Ignore certain decorators.',
    array: true,
    type: 'string',
})
    .option('use-community-edition', {
    description: 'Force using Redoc CE for docs preview.',
    type: 'boolean',
})
    .option('force', {
    alias: 'f',
    type: 'boolean',
    description: 'Produce bundle output even when errors occur.',
})
    .option('config', {
    description: 'Specify path to the config file.',
    type: 'string',
}), (argv) => __awaiter(void 0, void 0, void 0, function* () {
    preview_docs_1.previewDocs(argv);
}))
    .demandCommand(1)
    .strict().argv;
function getOutputFileName(entrypoint, entries, output, ext) {
    if (!output) {
        return { outputFile: 'stdout', ext: ext || 'yaml' };
    }
    let outputFile = output;
    if (entries > 1) {
        ext = ext || path_1.extname(entrypoint).substring(1);
        if (!outputExtensions.includes(ext)) {
            throw new Error(`Invalid file extension: ${ext}.`);
        }
        outputFile = path_1.join(output, path_1.basename(entrypoint, path_1.extname(entrypoint))) + '.' + ext;
    }
    else {
        if (output) {
            ext = ext || path_1.extname(output).substring(1);
        }
        ext = ext || path_1.extname(entrypoint).substring(1);
        if (!outputExtensions.includes(ext)) {
            throw new Error(`Invalid file extension: ${ext}.`);
        }
        outputFile = path_1.join(path_1.dirname(outputFile), path_1.basename(outputFile, path_1.extname(outputFile))) + '.' + ext;
    }
    return { outputFile, ext };
}
function handleError(e, ref) {
    if (e instanceof resolve_1.ResolveError) {
        process.stderr.write(`Failed to resolve entrypoint definition at ${ref}:\n\n  - ${e.message}.\n\n`);
    }
    else if (e instanceof resolve_1.YamlParseError) {
        process.stderr.write(`Failed to parse entrypoint definition at ${ref}:\n\n  - ${e.message}.\n\n`);
        // TODO: codeframe
    }
    else if (e instanceof utils_1.CircularJSONNotSupportedError) {
        process.stderr.write(colorette_1.red(`Detected circular reference which can't be converted to JSON.\n`) +
            `Try to use ${colorette_1.blue('yaml')} output or remove ${colorette_1.blue('--dereferenced')}.\n\n`);
    }
    else {
        process.stderr.write(`Something went wrong when processing ${ref}:\n\n  - ${e.message}.\n\n`);
        throw e;
    }
}
function printLintTotals(totals, definitionsCount) {
    const ignored = totals.ignored
        ? colorette_1.yellow(`${totals.ignored} ${pluralize('problem is', totals.ignored)} explicitly ignored.\n\n`)
        : '';
    if (totals.errors > 0) {
        process.stderr.write(colorette_1.red(`❌ Validation failed with ${totals.errors} ${pluralize('error', totals.errors)}${totals.warnings > 0
            ? ` and ${totals.warnings} ${pluralize('warning', totals.warnings)}`
            : ''}.\n${ignored}`));
    }
    else if (totals.warnings > 0) {
        process.stderr.write(colorette_1.green(`Woohoo! Your OpenAPI ${pluralize('definition is', definitionsCount)} valid. 🎉\n`));
        process.stderr.write(colorette_1.yellow(`You have ${totals.warnings} ${pluralize('warning', totals.warnings)}.\n${ignored}`));
    }
    else {
        process.stderr.write(colorette_1.green(`Woohoo! Your OpenAPI ${pluralize('definition is', definitionsCount)} valid. 🎉\n${ignored}`));
    }
    if (totals.errors > 0) {
        process.stderr.write(colorette_1.gray(`run with \`--generate-ignore-file\` to add all problems to ignore file.\n`));
    }
    process.stderr.write('\n');
}
function getTotals(problems) {
    let errors = 0;
    let warnings = 0;
    let ignored = 0;
    for (const m of problems) {
        if (m.ignored) {
            ignored++;
            continue;
        }
        if (m.severity === 'error')
            errors++;
        if (m.severity === 'warn')
            warnings++;
    }
    return {
        errors,
        warnings,
        ignored,
    };
}
exports.getTotals = getTotals;
function pluralize(label, num) {
    if (label.endsWith('is')) {
        [label] = label.split(' ');
        return num === 1 ? `${label} is` : `${label}s are`;
    }
    return num === 1 ? `${label}` : `${label}s`;
}
function getConfigDirectory(config) {
    return config.configFile ? path_1.dirname(config.configFile) : process.cwd();
}
function getAliasOrPath(config, aliasOrPath) {
    return config.apiDefinitions[aliasOrPath] || aliasOrPath;
}
function isNotEmptyArray(args) {
    return Array.isArray(args) && !!args.length;
}
function expandGlobsInEntrypoints(args, config) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield Promise.all(args.map((aliasOrPath) => __awaiter(this, void 0, void 0, function* () {
            return glob.hasMagic(aliasOrPath)
                ? (yield glob(aliasOrPath)).map((g) => getAliasOrPath(config, g))
                : getAliasOrPath(config, aliasOrPath);
        })))).flat();
    });
}
function getFallbackEntryPointsOrExit(argsEntrypoints, config) {
    return __awaiter(this, void 0, void 0, function* () {
        const { apiDefinitions } = config;
        const shouldFallbackToAllDefinitions = !isNotEmptyArray(argsEntrypoints) && apiDefinitions && Object.keys(apiDefinitions).length > 0;
        const res = shouldFallbackToAllDefinitions
            ? Object.values(apiDefinitions).map((fileName) => path_1.resolve(getConfigDirectory(config), fileName))
            : yield expandGlobsInEntrypoints(argsEntrypoints, config);
        if (!isNotEmptyArray(res)) {
            process.stderr.write(ERROR_MESSAGE.MISSING_ARGUMENT);
            process.exit(1);
        }
        return res;
    });
}
exports.getFallbackEntryPointsOrExit = getFallbackEntryPointsOrExit;
function printUnusedWarnings(config) {
    const { preprocessors, rules, decorators } = config.getUnusedRules();
    if (rules.length) {
        process.stderr.write(colorette_1.yellow(`[WARNING] Unused rules found in ${colorette_1.blue(config.configFile || '')}: ${rules.join(', ')}.\n`));
    }
    if (preprocessors.length) {
        process.stderr.write(colorette_1.yellow(`[WARNING] Unused preprocessors found in ${colorette_1.blue(config.configFile || '')}: ${preprocessors.join(', ')}.\n`));
    }
    if (decorators.length) {
        process.stderr.write(colorette_1.yellow(`[WARNING] Unused decorators found in ${colorette_1.blue(config.configFile || '')}: ${decorators.join(', ')}.\n`));
    }
    if (rules.length || preprocessors.length) {
        process.stderr.write(`Check the spelling and verify you added plugin prefix.\n`);
    }
}
